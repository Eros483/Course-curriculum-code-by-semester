# -*- coding: utf-8 -*-
"""CSD212_Demo-7_P2-Batch_Questions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NEj1eWV0Z4m3P4eKBeADvV-VBqAFU0Cd

# Prerequisite
* Load required packages and load images (already uploaded on Blackboard) in Colab
* Create your own copy of notebook and add required code snippets in between the questions subsections. Also display the figures at each stage.
*Colab can be exported as a notebook file or Python file by **File > Download .ipynb** or **File > Download .py**. Exported notebook files can be reloaded into Google Colab or used in Jupyter Notebook.
* Please go through [Colab document](https://colab.research.google.com/drive/1YKHHLSlG-B9Ez2-zf-YFxXTVgfC_Aqtt) for further information.

* **Use ONLY numpy and tensorflow/pytorch functions for any type of operations**  

* **Do not use any built-in opencv or anyother such function**
"""

import tensorflow as tf
import numpy as np
from scipy import ndimage as nd
from scipy import interpolate as inter
from matplotlib import pyplot as plt
import imageio.v2 as imageio

"""#a)Load 'barbara.jpg'

"""

img_path = '/content/barbara.jpg'
img_a0 = imageio.imread(img_path)
# img_a0 = tf.convert_to_tensor(img_a0, dtype=tf.float32)
# img_a = tf.image.rgb_to_grayscale(img_a0)
img_a = img_a0.astype(np.float32)
print('Original Data_type is {}'.format(img_a0.dtype))
print('Data_type is', img_a.dtype)
print('Image Size is {}'.format(img_a.shape))
print('Image min and max are ({}, {})'.format(img_a.min(),img_a.max()))
#################################################
plt.figure(figsize=(5,5))
plt.imshow(img_a, cmap='gray')
plt.axis('off')
plt.show()

"""#b) Apply DFT to a)"""

img_b = np.fft.fft2(img_a)
#################################################
print('FFT Data_type is {}'.format(img_b.dtype))
print('FFT Size is {}'.format(img_b.shape))
print('FFT min and max are ({}, {})'.format(img_b.min(),img_b.max()))
#################################################

#a = -1449185.750472431+241803.37904497175j
#b = np.abs(a)
#print(a)
#print(b)
img_b_mod = np.abs(img_b)
#################################################
print('mod-FFT Data_type is {}'.format(img_b_mod.dtype))
print('mod-FFT Size is {}'.format(img_b_mod.shape))
print('mod-FFT min and max are ({}, {})'.\
      format(img_b_mod.min(),img_b_mod.max()))
print('log mod-FFT min and max are ({}, {})'.\
      format(np.log2(1+img_b_mod.min()),np.log2(1+img_b_mod.max()) ))
#################################################

"""#c) Apply log to FFT"""

min_lb = np.log2(1+img_b_mod.min())
max_lb = np.log2(1+img_b_mod.max())

img_b_lm = np.log2(1+img_b_mod)
img_c = (img_b_lm-min_lb) / (max_lb - min_lb)
img_c = 255.0*img_c
#################################################
print('lm-FFT Data_type is {}'.format(img_c.dtype))
print('mod-FFT Size is {}'.format(img_c.shape))
print('mod-FFT min and max are ({}, {})'.format(img_c.min(),img_c.max()))
#################################################

plt.figure(figsize=(3,3))
plt.imshow(img_c, cmap='gray')
plt.axis('off')
plt.show()

"""#d) Apply fft-shift to image a) and then apply fft"""

img_fft_a = np.fft.fft2(img_a)
img_d = np.fft.fftshift(img_fft_a)
#################################################
print('shift-FFT Data_type is {}'.format(img_d.dtype))
print('shift-FFT Size is {}'.format(img_d.shape))
print('shift-FFT min and max are ({}, {})'.format(img_d.min(),img_d.max()))
#################################################

img_d_mod = np.abs(img_d)
min_ld = np.log2(1+img_d_mod.min())
max_ld = np.log2(1+img_d_mod.max())

img_d_lm = np.log2(1+img_d_mod)
img_e = (img_d_lm-min_ld) / (max_ld - min_ld)
img_e = 255.0*img_e
#################################################
print('shift-lm-FFT Data_type is {}'.format(img_e.dtype))
print('shift-mod-FFT Size is {}'.format(img_e.shape))
print('shift-mod-FFT min and max are ({}, {})'.format(img_e.min(),img_e.max()))
#################################################

plt.figure(figsize=(3,3))
plt.imshow(img_e, cmap='gray')
plt.axis('off')
plt.show()

"""#f)Creating meshgrid for coordinate locations"""

print(img_a0.shape)
c_x = np.floor(img_a0.shape[0]/2)
c_y = np.floor(img_a0.shape[1]/2)
print((c_x,c_y))
[ii,jj] = np.meshgrid(range(img_a0.shape[0]), \
                      range(img_a0.shape[1]),indexing='ij')
print(ii)
print(jj)

dist = np.sqrt(np.power(ii-c_x,2) + np.power(jj-c_y,2))
plt.figure(figsize=(3,3))
plt.imshow(dist, cmap='gray')
plt.axis('off')
plt.show()

"""#g) creating Ideal Low pass filter of radius 80"""

H_low = (dist <= 80)
plt.figure(figsize=(3,3))
plt.imshow(H_low, cmap='gray')
plt.axis('off')
plt.show()

"""#h)Apply low pass filter to a)"""

fft_low_shifted = img_d*H_low  # convolution spatial domain
fft_low = np.fft.ifftshift(fft_low_shifted)
img_low = np.fft.ifft2(fft_low)
print('Data_type is', img_low.dtype)
print('Image Size is {}'.format(img_low.shape))
print('Image min and max are ({}, {})'.format(img_low.min(),img_low.max()))

img_low = img_low.real
print('Data_type is', img_low.dtype)
print('Image Size is {}'.format(img_low.shape))
print('Image min and max are ({}, {})'.format(img_low.min(),img_low.max()))

plt.figure(figsize=(5,5))
plt.imshow(img_low, cmap='gray')
plt.axis('off')
plt.show()

"""#Q1.a) load 'barbara_noisy02.jpg' and calculate its shifted DFT. Display it using log-transform [0 Marks]

#Q1.b) Apply Ideal Low Pass Filter with radius 80 to Q1.a) image [0 Marks]

---

#Q1.c) Apply Butterworth Lowpass Filter with $D_0=60$ to Q1.a) image by creating your own function  [2 Marks]

#Q1.d)Apply Gaussian Lowpass Filter with suitable $D_0$ to Q1.a) image such that RMSE with noiseless 'barbara.jpg' is lowest by creating your own function [4 Marks]

# Q2) Apply all three HighPass Filter to 'barbara_noisy02.jpg' with $D_0$ as 40,70,and 90 respectively by creating your own function and display the results [4 Marks\]
"""
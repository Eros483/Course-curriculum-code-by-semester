Roll no: 2310110428
Name: Arnab Mandal

Program-1:

#include <stdio.h>
#include <stdlib.h>

struct TreeNode{
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
};

struct TreeNode* createNode(int value);//function to create nodes to simplify logic

struct TreeNode* insertNode(struct TreeNode* root, int value);

void inOrderTraversal(struct TreeNode* root);

int main(){
    struct TreeNode* root=NULL;
    int nodeValue, n;
    scanf("%d", &n);
    for (int i=0; i<n; i++)
    {
        scanf("%d", &nodeValue);
        root=insertNode(root, nodeValue);
    }


    inOrderTraversal(root);

    return 0;
}

struct TreeNode* createNode(int value)
{
    struct TreeNode* newNode=(struct TreeNode*)malloc(sizeof(struct TreeNode));//allocating memory for new node
    newNode->data=value;
    newNode->left=NULL;
    newNode->right=NULL;
    return newNode;
}

struct TreeNode* insertNode(struct TreeNode* root, int value)
{
    if (root==NULL)//assuming empty tree
    {
        root=createNode(value);
        return root;
    }

    if (root->left==NULL)//assuming left node is empty
    {
        root->left=createNode(value);
    }

    else if (root->right==NULL)//if left node is filled but right is empty
    {
        root->right=createNode(value);
    }

    else//both left and right are filled, and thus recursively checking for the left node of the root
    {
        insertNode(root->left, value);
    }

    return root;
}

void inOrderTraversal(struct TreeNode* root)
{
    if (root!=NULL)
    {
        inOrderTraversal(root->left);//going to the left node and setting up recursive
        printf("%d ", root->data);//printing values
        inOrderTraversal(root->right);//going to the right, then to the left and setting up recursive
    }
}

Program-2:

#include <stdio.h>
#include <stdlib.h>

struct TreeNode{
    int data;
    struct TreeNode* left;
    struct TreeNode* right;
};

struct TreeNode* insertNode(struct TreeNode* root, int value);

void inOrderTraversal(struct TreeNode* root);

int main(){
    struct TreeNode* root=NULL;
    int nodeValue, n;
    scanf("%d", &n);
    for (int i=0; i<n; i++)
    {
        scanf("%d", &nodeValue);
        root=insertNode(root, nodeValue);
    }


    inOrderTraversal(root);

    return 0;
}

struct TreeNode* insertNode(struct TreeNode* root, int value)
{
    if (root==NULL)//assuming empty tree
    {
        struct TreeNode*newNode=(struct TreeNode*)malloc(sizeof(struct TreeNode));
        newNode->data=value;
        newNode->left=NULL;
        newNode->right=NULL;
        return newNode;
    }

    if (value<root->data)//if value is smaller than tree root
    {
        root->left=insertNode(root->left, value);
    }

    if (value>root->data)//if value is greater than tree root
    {
        root->right=insertNode(root->right, value);
    }

    return root;
}

void inOrderTraversal(struct TreeNode* root)//requisite code
{
    if (root!=NULL)
    {
        inOrderTraversal(root->left);//going to the left node and setting up recursive
        printf("%d ", root->data);//printing values
        inOrderTraversal(root->right);//going to the right, then to the left and setting up recursive
    }
}

Program-3:
#include <stdio.h>
#include <stdlib.h>

struct TreeNode{
    int data;
    struct TreeNode*left;
    struct TreeNode*right;
};

struct TreeNode* insertNode(struct TreeNode*root, int value);

int treeHeight(struct TreeNode*root);

int main(){
    struct TreeNode* root=NULL;
    int nodeValue, n;
    scanf("%d", &n);
    for (int i=0; i<n; i++)
    {
        scanf("%d", &nodeValue);
        root=insertNode(root, nodeValue);
    }


    int height=treeHeight(root);
    printf("%d ", height);
    return 0;
}

struct TreeNode* insertNode(struct TreeNode* root, int value)
{
    if (root==NULL)//assuming empty tree
    {
        struct TreeNode*newNode=(struct TreeNode*)malloc(sizeof(struct TreeNode));
        newNode->data=value;
        newNode->left=NULL;
        newNode->right=NULL;
        return newNode;
    }

    if (value<root->data)//if value is smaller than tree root
    {
        root->left=insertNode(root->left, value);
    }

    if (value>root->data)//if value is greater than tree root
    {
        root->right=insertNode(root->right, value);
    }

    return root;
}

int treeHeight(struct TreeNode*root)
{
    if (root==NULL)//handling empty tree
    {
        return 0;
    }

    int left=treeHeight(root->left);//recursively finding height of each left subbranch
    int right=treeHeight(root->right);//recursively finding height of each right subbranch

    return 1+(left>right?left:right);//simultaneously incrementing while returning higher value from base node
}


